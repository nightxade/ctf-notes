# Description
This exploit targets a vulnerability in the Linux network packet scheduler's SFQ queueing discipline. Essentially (skipping over the smaller details), it uses a type confusion bug (and spraying `sfq_slots` in `kmalloc-64` to avoid a segmentation fault) to cause an underflow, leading to a large (0x401EC) out-of-bounds write.

This can be exploited by spraying the SFQ Qdisc (`struct Qdisc + struct sfq_sched_data`) in `kmalloc-2k` and the`pipe_inode_info` object in `kmalloc-192` , in the following format.
![[CVE-2025-37752, kmalloc spraying.png|750]]
That is, we:
1. Allocate lots of named pipes with `mkfifo()`
2. Drain unmovable pages from order 0 to 3
> This way, subsequent requests will force the buddy allocator to split higher order pages into lower order buddies. This will give us access to relatively large portions of contiguous memory. \[1\]
3. Spray the memory with our desired structure (alternating between 256KB of SFQ Qdiscs and 256KB of named pipes). Currently, `pipe->files = 1` for all pipes, since this is the reference count field for each pipe
4. OOB write enables us to set `pipe->files = 0` for one pipe, since it is at the right offset
5. Reopen all named pipes, incrementing `pipe->files` for all pipes
6. Close all named pipes, decrementing `pipe->files` for all pipes. Notably, `pipe->files = 0` for our victim pipe
7. This results in `free_pipe_inode` being called to free the `pipe_inode_info` struct. This frees `pipe->tmp_page`, thus providing a page UAF since we retain access to the victim pipe.

`pipe->tmp_page` was allocated [here](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L502), with flags `alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT)`.

> GFP_HIGHUSER means that the allocated memory is not movable, but it is not required to be directly accessible by the kernel. An example may be a hardware allocation that maps data directly into userspace but has no addressing limitations. \[2\]

According to the blog, the kernel is actually requesting an unmovable order 0 page. Upon freeing, it can be reclaimed using a slab in an order 0 page with the same migration type, unmovable.

The final stage of the exploit is using a `filp` slab containing `signalfd` files. (`filp` appears to be for `file` structs). Using `pipe_read()` and `pipe_write()` (in `fs/pipe.c`, likely as `fifo_pipe_read/write` now) allows swapping `file->private_data` with `file->f_cred` ([`stashed credentials of creator/opener`](https://elixir.bootlin.com/linux/v6.16/source/include/linux/fs.h#L1080)). Multiple writes allow us to overwrite `file->f_cred` with zeros, i.e. overwrites the process credentials with zeros, granting root access thanks to the following:
```c
static int do_signalfd4(int ufd, sigset_t *mask, int flags)
{
	struct signalfd_ctx *ctx;

	// ...

	if (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))
		return -EINVAL;

	sigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));
	signotset(mask);

	if (ufd == -1) {
		struct file *file;

		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
		if (!ctx)
			return -ENOMEM;

		ctx->sigmask = *mask;

		// ...
		file = anon_inode_getfile("[signalfd]", &signalfd_fops, ctx,
				       O_RDWR | (flags & O_NONBLOCK));
		// ...
	} else {
		// ...
		// We swapped file->private_data with file->f_cred
		// So here ctx = file->f_cred
		ctx = fd_file(f)->private_data; 
		// ...
		ctx->sigmask = *mask; // Overwrite f_cred
		// ...
	}

	return ufd;
}
```
[Full exploit code](https://raw.githubusercontent.com/0xdevil/security-research/CVE-2025-37752/pocs/linux/kernelctf/CVE-2025-37752_cos/exploit/cos-105-17412.535.78/exploit.c)
# References
1. https://syst3mfailure.io/two-bytes-of-madness/ (a lot was paraphrased from here)
2. https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html